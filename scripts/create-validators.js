/*! Copyright (c) 2021 Siemens AG. Licensed under the MIT License. */

const { validator } = require("@exodus/schemasafe");
const fse = require("fs-extra");
const os = require("os");
const path = require("path");
const jsonSchemaToLang = require("vda-5050-cli/lib/schema");
const vda5050SchemaDir = path.join(path.dirname(require.resolve("vda-5050-cli/lib/schema")), "../schema/");

/**
 * Create a standalone JS module including pre-compiled validation functions of
 * the core VDA 5050 JSON schemas that can be used without additional runtime
 * dependencies.
 *
 * @param vdaVersion the VDA 5050 specification version the schemas are related
 * to
 * @param moduleFormat generated JS module format, either "esm" or "commonjs"
 * (optional, default is "commonjs")
 */
async function createCoreValidators(vdaVersion, moduleFormat) {
    const moduleFile = `src/common/vda-5050-validators-${vdaVersion}.js`;
    const exportFolder = fse.mkdtempSync(path.join(os.tmpdir(), "vda-5050-schema-"));
    try {
        await jsonSchemaToLang({ lang: "json", vda: vdaVersion, out: exportFolder, vda5050SchemaDir });
        const schemas = [];
        fse.readdirSync(exportFolder).forEach(file => {
            if (file !== "common.schema.json") {
                schemas.push(path.join(exportFolder, file));
            }
        });
        createValidators(
            schemas,
            [path.join(exportFolder, "common.schema.json")],
            moduleFile,
            moduleFormat);
        console.log(`Generated file '${moduleFile}' with ${schemas.length} validation functions.`);
    } finally {
        try {
            fse.removeSync(exportFolder);
        } catch { }
    }
}

/**
 * Create a standalone JS module including pre-compiled validation functions for
 * each of the specified schemas that can be used without additional runtime
 * dependencies.
 *
 * @remarks
 * Schemas referred to by `$ref` must be specified separately.
 *
 * The generated validation functions are named as follows:
 * `validate<Capitalized schema title keyword>`.
 *
 * @param schemaFiles an array of paths to JSON schemas for which to create
 * validation functions
 * @param refSchemaFiles an array of paths to JSON schemas resolving $ref
 * references
 * @param moduleFile the CommonJS module file containing the generated
 * validation functions
 * @param moduleFormat generated JS module format, either "esm" or "commonjs"
 * (optional, default is "commonjs")
 */
function createValidators(schemaFiles, refSchemaFiles, moduleFile, moduleFormat) {
    const refSchemas = [];
    const modules = [];
    for (const refFile of refSchemaFiles) {
        refSchemas.push(JSON.parse(fse.readFileSync(refFile)));
    }
    for (const file of schemaFiles) {
        const schema = JSON.parse(fse.readFileSync(file));
        const validate = validator(schema, { includeErrors: true, schemas: refSchemas, allowUnusedKeywords: true });
        const moduleFunc = `validate${schema.title[0].toUpperCase()}${schema.title.substring(1)}`;
        modules.push([moduleFunc, `const ${moduleFunc} = ${validate.toModule()}\n`]);
    }
    let code = String.raw
        `// ----------------------------------------------------------------------------"
// This file was generated by a tool, do not modify it directly.
// ----------------------------------------------------------------------------

`;
    code += modules.map(m => m[1]).join("\n");

    switch (moduleFormat) {
        case "esm":
            code += `export { ${modules.map(m => m[0]).join(", ")} };`;
            break;
        case "commonjs":
        default:
            code += `module.exports = { ${modules.map(m => m[0]).join(", ")} };`;
            break;
    }

    fse.writeFileSync(moduleFile, code);
}

module.exports = { createCoreValidators, createValidators };
